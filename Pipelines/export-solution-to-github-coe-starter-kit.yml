# This pipeline gets triggered manually or via an API call.  
# It is a general purpose automation that allows you to export a solution from a Dataverse environment and commit it to a git branch.
# It facilitates:
# -Ensuring user can be part of the commit (instead of a generic user), thereby enabling tracking of who made what changes
# -Reuse for any solution in any Dataverse environment

# The following variables need to be set when the pipeline is queued to run:
# Project: The name of the Azure DevOps Project to which we are exporting our solution.
# Repo: The name of the Azure DevOps Repo to which we are exporting our solution.
# Branch: The name of the Azure DevOps Branch in the Repo above to which we are exporting our solution.
# BranchToCreate: The name of the new Azure DevOps Branch to create in the Repo above to which we are exporting our solution (Optional).
# CommitMessage: The commit message for this commit.
# Email: The email of the user performing the commit.
# ServiceConnection: The name of the service connection to Power Platform from which we'll be pulling the solution.
# SolutionName: The name of the solution being exported (i.e. Not the Display Name).
# UserName: The Display name of the user performing the commit.
# Data: Additional Data (e.g. JSON Payload) for the export to configure deployment pipelines
trigger: none
pr: none

name: export-$(SolutionName)-to-git-branch

resources:
  repositories:
  - repository: SourceRepo
    type: github
    endpoint: coe-starter-kit
    name: Microsoft/coe-starter-kit
    
variables:
- group: alm-accelerator-variable-group

pool:
  vmImage: 'windows-2022'

steps:

# Checkout Pipelines
- checkout: self
  path: 'PipelineUtils'
  displayName: 'Checkout Pipeline Branch'

# Checkout our GitHub Branch
- checkout: SourceRepo
  displayName: 'Checkout Source Branch'

# Other tasks, which use the PowerApps PowerShell cmdlets, need the environment guid.  Setting it for future use.
- template: Templates\export-Solution.yml
  parameters:
    gitAccessUrl: $(GitAccessUrl)
    project: $(Project)
    repo: $(Repo)
    branch: $(Branch)
    branchToCreate: $(BranchToCreate)
    commitMessage: $(CommitMessage)
    email: $(Email)
    serviceConnection: $(ServiceConnection)
    solutionName: $(SolutionName)
    userName: $(UserName)    
    configurationData: $(Data)

# Checkout our Azure DevOps Branch
- checkout: git://$(Project)/$(Repo)@$(Branch)
  path: 'DevopsSource'
  displayName: 'Checkout Source Branch'
  condition: and(succeeded(), ne(variables.BranchToCreate, ''), ne(variables.BranchToCreate, variables.SolutionName)) # If an empty value is passed for the BranchToCreate variable, then skip this task

  # If BranchToCreate variable value is not '', then push to the branch specified in the BranchToCreate variable
- script: |
   git -c http.extraheader="AUTHORIZATION: bearer $(System.AccessToken)" fetch --all
   git -c http.extraheader="AUTHORIZATION: bearer $(System.AccessToken)" checkout -b $(BranchToCreate)
   git -c http.extraheader="AUTHORIZATION: bearer $(System.AccessToken)" push --set-upstream origin $(BranchToCreate)
  workingDirectory: $(Pipeline.Workspace)\DevopsSource
  displayName: 'Push to Azure DevOps $(BranchToCreate) Remote Branch'
  condition: and(succeeded(), ne(variables.BranchToCreate, ''), ne(variables.BranchToCreate, variables.SolutionName)) # If an empty value is not passed for the BranchToCreate variable, then run this task
    